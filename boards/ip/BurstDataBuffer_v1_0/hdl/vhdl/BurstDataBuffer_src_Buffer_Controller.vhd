-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/axis_combine/BurstDataBuffer_src_Buffer_Controller.vhd
-- Created: 2023-01-10 15:52:58
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: BurstDataBuffer_src_Buffer_Controller
-- Source Path: axis_combine/Burst Data/Buffer Controller
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY BurstDataBuffer_src_Buffer_Controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        validIn                           :   IN    std_logic;
        tlastIn                           :   IN    std_logic;
        wrEn0                             :   OUT   std_logic;
        wrEn1                             :   OUT   std_logic;
        bufferSelect                      :   OUT   std_logic;
        ram0Addr                          :   OUT   std_logic_vector(12 DOWNTO 0);  -- ufix13
        ram1Addr                          :   OUT   std_logic_vector(12 DOWNTO 0);  -- ufix13
        validOut                          :   OUT   std_logic;
        tlastOut                          :   OUT   std_logic
        );
END BurstDataBuffer_src_Buffer_Controller;


ARCHITECTURE rtl OF BurstDataBuffer_src_Buffer_Controller IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL ram0Addr_tmp                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL ram1Addr_tmp                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL reg_wrEn0                        : std_logic;
  SIGNAL reg_wrEn1                        : std_logic;
  SIGNAL reg_wrCount                      : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL reg_rdCount                      : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL reg_flag_first_write             : std_logic;
  SIGNAL reg_tlastIn                      : std_logic;
  SIGNAL reg_flag_read_ping               : std_logic;
  SIGNAL reg_flag_write_ping              : std_logic;
  SIGNAL reg_flag_read_pong               : std_logic;
  SIGNAL reg_flag_write_pong              : std_logic;
  SIGNAL state                            : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL reg_wrEn0_next                   : std_logic;
  SIGNAL reg_wrEn1_next                   : std_logic;
  SIGNAL reg_wrCount_next                 : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL reg_rdCount_next                 : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL reg_flag_first_write_next        : std_logic;
  SIGNAL reg_tlastIn_next                 : std_logic;
  SIGNAL reg_flag_read_ping_next          : std_logic;
  SIGNAL reg_flag_write_ping_next         : std_logic;
  SIGNAL reg_flag_read_pong_next          : std_logic;
  SIGNAL reg_flag_write_pong_next         : std_logic;
  SIGNAL state_next                       : unsigned(4 DOWNTO 0);  -- ufix5

BEGIN
  Buffer_Controller_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reg_wrEn0 <= '0';
      reg_wrEn1 <= '0';
      reg_wrCount <= to_unsigned(16#0000#, 13);
      reg_rdCount <= to_unsigned(16#0000#, 13);
      reg_flag_first_write <= '0';
      reg_tlastIn <= '0';
      reg_flag_read_ping <= '1';
      reg_flag_write_ping <= '0';
      reg_flag_read_pong <= '1';
      reg_flag_write_pong <= '0';
      state <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reg_wrEn0 <= reg_wrEn0_next;
        reg_wrEn1 <= reg_wrEn1_next;
        reg_wrCount <= reg_wrCount_next;
        reg_rdCount <= reg_rdCount_next;
        reg_flag_first_write <= reg_flag_first_write_next;
        reg_tlastIn <= reg_tlastIn_next;
        reg_flag_read_ping <= reg_flag_read_ping_next;
        reg_flag_write_ping <= reg_flag_write_ping_next;
        reg_flag_read_pong <= reg_flag_read_pong_next;
        reg_flag_write_pong <= reg_flag_write_pong_next;
        state <= state_next;
      END IF;
    END IF;
  END PROCESS Buffer_Controller_process;

  Buffer_Controller_output : PROCESS (reg_flag_first_write, reg_flag_read_ping, reg_flag_read_pong,
       reg_flag_write_ping, reg_flag_write_pong, reg_rdCount, reg_tlastIn,
       reg_wrCount, reg_wrEn0, reg_wrEn1, state, tlastIn, validIn)
    VARIABLE reg_wrEn0_temp : std_logic;
    VARIABLE reg_wrEn1_temp : std_logic;
    VARIABLE reg_flag_first_write_temp : std_logic;
    VARIABLE reg_flag_read_ping_temp : std_logic;
    VARIABLE reg_flag_write_ping_temp : std_logic;
    VARIABLE reg_flag_read_pong_temp : std_logic;
    VARIABLE reg_flag_write_pong_temp : std_logic;
  BEGIN
    reg_wrEn0_temp := reg_wrEn0;
    reg_wrEn1_temp := reg_wrEn1;
    reg_flag_first_write_temp := reg_flag_first_write;
    reg_flag_read_ping_temp := reg_flag_read_ping;
    reg_flag_write_ping_temp := reg_flag_write_ping;
    reg_flag_read_pong_temp := reg_flag_read_pong;
    reg_flag_write_pong_temp := reg_flag_write_pong;
    reg_wrCount_next <= reg_wrCount;
    reg_rdCount_next <= reg_rdCount;
    state_next <= state;
    -- States
    bufferSelect <= '0';
    wrEn0 <= '0';
    wrEn1 <= '0';
    ram0Addr_tmp <= to_unsigned(16#0000#, 13);
    ram1Addr_tmp <= to_unsigned(16#0000#, 13);
    validOut <= '0';
    tlastOut <= '0';
    -- State machine
    CASE state IS
      WHEN "00000" =>
        IF validIn = '1' THEN 
          state_next <= to_unsigned(16#01#, 5);
          reg_wrEn0_temp := '1';
          reg_wrCount_next <= reg_wrCount + to_unsigned(16#0001#, 13);
        ELSE 
          reg_wrEn0_temp := '0';
        END IF;
        wrEn0 <= reg_wrEn0_temp;
      WHEN "00001" =>
        IF validIn = '1' THEN 
          IF (hdlcoder_to_stdlogic(reg_wrCount = to_unsigned(16#0FFF#, 13)) OR (tlastIn AND ( NOT reg_tlastIn))) = '1' THEN 
            reg_flag_first_write_temp := '1';
            ram0Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= to_unsigned(16#0000#, 13);
          ELSE 
            ram0Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= reg_wrCount + to_unsigned(16#0001#, 13);
          END IF;
          reg_wrEn0_temp := '1';
        ELSE 
          reg_wrEn0_temp := '0';
        END IF;
        wrEn0 <= reg_wrEn0_temp;
        IF reg_flag_first_write_temp = '1' THEN 
          state_next <= to_unsigned(16#02#, 5);
          reg_rdCount_next <= to_unsigned(16#0000#, 13);
          reg_wrCount_next <= to_unsigned(16#0000#, 13);
        END IF;
      WHEN "00010" =>
        IF reg_flag_read_ping = '1' THEN 
          IF reg_rdCount = to_unsigned(16#0FFF#, 13) THEN 
            reg_flag_read_ping_temp := '0';
            tlastOut <= '1';
            ram0Addr_tmp <= reg_rdCount;
            reg_rdCount_next <= to_unsigned(16#0000#, 13);
          ELSE 
            ram0Addr_tmp <= reg_rdCount;
            reg_rdCount_next <= reg_rdCount + to_unsigned(16#0001#, 13);
          END IF;
          validOut <= '1';
        END IF;
        reg_wrEn0_temp := '0';
        wrEn0 <= '0';
        IF validIn = '1' THEN 
          IF (hdlcoder_to_stdlogic(reg_wrCount = to_unsigned(16#0FFF#, 13)) OR (tlastIn AND ( NOT reg_tlastIn))) = '1' THEN 
            reg_flag_write_ping_temp := '1';
            ram1Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= to_unsigned(16#0000#, 13);
          ELSE 
            ram1Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= reg_wrCount + to_unsigned(16#0001#, 13);
          END IF;
          reg_wrEn1_temp := '1';
        ELSE 
          reg_wrEn1_temp := '0';
        END IF;
        wrEn1 <= reg_wrEn1_temp;
        IF (reg_flag_write_ping_temp AND ( NOT reg_flag_read_ping_temp)) = '1' THEN 
          state_next <= to_unsigned(16#03#, 5);
          reg_flag_write_ping_temp := '0';
          reg_rdCount_next <= to_unsigned(16#0000#, 13);
          reg_wrCount_next <= to_unsigned(16#0000#, 13);
        END IF;
      WHEN "00011" =>
        IF reg_flag_read_pong = '1' THEN 
          IF reg_rdCount = to_unsigned(16#0FFF#, 13) THEN 
            reg_flag_read_pong_temp := '0';
            ram1Addr_tmp <= reg_rdCount;
            reg_rdCount_next <= to_unsigned(16#0000#, 13);
          ELSE 
            ram1Addr_tmp <= reg_rdCount;
            reg_rdCount_next <= reg_rdCount + to_unsigned(16#0001#, 13);
          END IF;
          validOut <= '1';
        END IF;
        bufferSelect <= '1';
        reg_wrEn1_temp := '0';
        wrEn1 <= '0';
        IF validIn = '1' THEN 
          IF (hdlcoder_to_stdlogic(reg_wrCount = to_unsigned(16#0FFF#, 13)) OR (tlastIn AND ( NOT reg_tlastIn))) = '1' THEN 
            reg_flag_write_pong_temp := '1';
            ram0Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= to_unsigned(16#0000#, 13);
          ELSE 
            ram0Addr_tmp <= reg_wrCount;
            reg_wrCount_next <= reg_wrCount + to_unsigned(16#0001#, 13);
          END IF;
          reg_wrEn0_temp := '1';
        ELSE 
          reg_wrEn0_temp := '0';
        END IF;
        wrEn0 <= reg_wrEn0_temp;
        IF (reg_flag_write_pong_temp AND ( NOT reg_flag_read_pong_temp)) = '1' THEN 
          state_next <= to_unsigned(16#02#, 5);
          reg_flag_write_pong_temp := '0';
          reg_flag_read_pong_temp := '1';
          reg_rdCount_next <= to_unsigned(16#0000#, 13);
          reg_wrCount_next <= to_unsigned(16#0000#, 13);
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    -- Edge detectors
    reg_tlastIn_next <= tlastIn;
    reg_wrEn0_next <= reg_wrEn0_temp;
    reg_wrEn1_next <= reg_wrEn1_temp;
    reg_flag_first_write_next <= reg_flag_first_write_temp;
    reg_flag_read_ping_next <= reg_flag_read_ping_temp;
    reg_flag_write_ping_next <= reg_flag_write_ping_temp;
    reg_flag_read_pong_next <= reg_flag_read_pong_temp;
    reg_flag_write_pong_next <= reg_flag_write_pong_temp;
  END PROCESS Buffer_Controller_output;


  ram0Addr <= std_logic_vector(ram0Addr_tmp);

  ram1Addr <= std_logic_vector(ram1Addr_tmp);

END rtl;

