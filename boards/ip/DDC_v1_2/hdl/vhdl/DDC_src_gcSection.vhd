-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/ddcduc/DDC_src_gcSection.vhd
-- Created: 2023-01-04 14:03:17
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DDC_src_gcSection
-- Source Path: ddcduc/DDC/CICDecimation/gcSection
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DDC_src_DDC_pkg.ALL;

ENTITY DDC_src_gcSection IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        combOut_re                        :   IN    std_logic_vector(20 DOWNTO 0);  -- sfix21_En10
        combOut_im                        :   IN    std_logic_vector(20 DOWNTO 0);  -- sfix21_En10
        downsampleValInd                  :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
        internalReset                     :   IN    std_logic;
        gcOut_re                          :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En17
        gcOut_im                          :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En17
        );
END DDC_src_gcSection;


ARCHITECTURE rtl OF DDC_src_gcSection IS

  -- Signals
  SIGNAL combOut_re_signed                : signed(20 DOWNTO 0);  -- sfix21_En10
  SIGNAL bShift_re                        : signed(17 DOWNTO 0);  -- sfix18_En7
  SIGNAL bShiftreg_re                     : signed(27 DOWNTO 0);  -- sfix28_En17
  SIGNAL bRShift_re                       : signed(27 DOWNTO 0);  -- sfix28_En17
  SIGNAL coarseGtmpreg_re                 : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL intdelay_reg                     : vector_of_signed18(0 TO 1);  -- sfix18 [2]
  SIGNAL coarseGtmp_re                    : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL fineMultreg                      : signed(22 DOWNTO 0);  -- sfix23_En21
  SIGNAL intdelay_reg_1                   : vector_of_signed23(0 TO 1);  -- sfix23 [2]
  SIGNAL fineG                            : signed(22 DOWNTO 0);  -- sfix23_En21
  SIGNAL mulOut_re                        : signed(40 DOWNTO 0);  -- sfix41_En38
  SIGNAL intdelay_reg_2                   : vector_of_signed41(0 TO 4);  -- sfix41 [5]
  SIGNAL mulOutreg_re                     : signed(40 DOWNTO 0);  -- sfix41_En38
  SIGNAL gcOutreg_re                      : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL intdelay_reg_3                   : vector_of_signed18(0 TO 1);  -- sfix18 [2]
  SIGNAL gcOut_re_tmp                     : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL combOut_im_signed                : signed(20 DOWNTO 0);  -- sfix21_En10
  SIGNAL bShift_im                        : signed(17 DOWNTO 0);  -- sfix18_En7
  SIGNAL bShiftreg_im                     : signed(27 DOWNTO 0);  -- sfix28_En17
  SIGNAL bRShift_im                       : signed(27 DOWNTO 0);  -- sfix28_En17
  SIGNAL coarseGtmpreg_im                 : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL intdelay_reg_4                   : vector_of_signed18(0 TO 1);  -- sfix18 [2]
  SIGNAL coarseGtmp_im                    : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL mulOut_im                        : signed(40 DOWNTO 0);  -- sfix41_En38
  SIGNAL intdelay_reg_5                   : vector_of_signed41(0 TO 4);  -- sfix41 [5]
  SIGNAL mulOutreg_im                     : signed(40 DOWNTO 0);  -- sfix41_En38
  SIGNAL gcOutreg_im                      : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL intdelay_reg_6                   : vector_of_signed18(0 TO 1);  -- sfix18 [2]
  SIGNAL gcOut_im_tmp                     : signed(17 DOWNTO 0);  -- sfix18_En17

BEGIN
  combOut_re_signed <= signed(combOut_re);

  
  bShift_re <= "011111111111111111" WHEN (combOut_re_signed(20) = '0') AND (combOut_re_signed(19 DOWNTO 3) = "11111111111111111") ELSE
      combOut_re_signed(20 DOWNTO 3) + ('0' & combOut_re_signed(2));

  bShiftreg_re <= bShift_re & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  bRShift_re <= SHIFT_RIGHT(bShiftreg_re, 10);

  
  coarseGtmpreg_re <= "011111111111111111" WHEN (bRShift_re(27) = '0') AND (bRShift_re(26 DOWNTO 17) /= "0000000000") ELSE
      "100000000000000000" WHEN (bRShift_re(27) = '1') AND (bRShift_re(26 DOWNTO 17) /= "1111111111") ELSE
      bRShift_re(17 DOWNTO 0);

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg(0) <= coarseGtmpreg_re;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  coarseGtmp_re <= intdelay_reg(1);

  fineMultreg <= to_signed(16#200000#, 23);

  intdelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_1 <= (OTHERS => to_signed(16#000000#, 23));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_1(0) <= fineMultreg;
        intdelay_reg_1(1) <= intdelay_reg_1(0);
      END IF;
    END IF;
  END PROCESS intdelay_1_process;

  fineG <= intdelay_reg_1(1);

  mulOut_re <= coarseGtmp_re * fineG;

  intdelay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_2 <= (OTHERS => to_signed(0, 41));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_2(0) <= mulOut_re;
        intdelay_reg_2(1 TO 4) <= intdelay_reg_2(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_2_process;

  mulOutreg_re <= intdelay_reg_2(4);

  
  gcOutreg_re <= "011111111111111111" WHEN ((mulOutreg_re(40) = '0') AND (mulOutreg_re(39 DOWNTO 38) /= "00")) OR ((mulOutreg_re(40) = '0') AND (mulOutreg_re(38 DOWNTO 21) = "011111111111111111")) ELSE
      "100000000000000000" WHEN (mulOutreg_re(40) = '1') AND (mulOutreg_re(39 DOWNTO 38) /= "11") ELSE
      mulOutreg_re(38 DOWNTO 21) + ('0' & mulOutreg_re(20));

  intdelay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_3 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_3(0) <= gcOutreg_re;
        intdelay_reg_3(1) <= intdelay_reg_3(0);
      END IF;
    END IF;
  END PROCESS intdelay_3_process;

  gcOut_re_tmp <= intdelay_reg_3(1);

  gcOut_re <= std_logic_vector(gcOut_re_tmp);

  combOut_im_signed <= signed(combOut_im);

  
  bShift_im <= "011111111111111111" WHEN (combOut_im_signed(20) = '0') AND (combOut_im_signed(19 DOWNTO 3) = "11111111111111111") ELSE
      combOut_im_signed(20 DOWNTO 3) + ('0' & combOut_im_signed(2));

  bShiftreg_im <= bShift_im & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  bRShift_im <= SHIFT_RIGHT(bShiftreg_im, 10);

  
  coarseGtmpreg_im <= "011111111111111111" WHEN (bRShift_im(27) = '0') AND (bRShift_im(26 DOWNTO 17) /= "0000000000") ELSE
      "100000000000000000" WHEN (bRShift_im(27) = '1') AND (bRShift_im(26 DOWNTO 17) /= "1111111111") ELSE
      bRShift_im(17 DOWNTO 0);

  intdelay_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_4 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_4(0) <= coarseGtmpreg_im;
        intdelay_reg_4(1) <= intdelay_reg_4(0);
      END IF;
    END IF;
  END PROCESS intdelay_4_process;

  coarseGtmp_im <= intdelay_reg_4(1);

  mulOut_im <= coarseGtmp_im * fineG;

  intdelay_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_5 <= (OTHERS => to_signed(0, 41));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_5(0) <= mulOut_im;
        intdelay_reg_5(1 TO 4) <= intdelay_reg_5(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_5_process;

  mulOutreg_im <= intdelay_reg_5(4);

  
  gcOutreg_im <= "011111111111111111" WHEN ((mulOutreg_im(40) = '0') AND (mulOutreg_im(39 DOWNTO 38) /= "00")) OR ((mulOutreg_im(40) = '0') AND (mulOutreg_im(38 DOWNTO 21) = "011111111111111111")) ELSE
      "100000000000000000" WHEN (mulOutreg_im(40) = '1') AND (mulOutreg_im(39 DOWNTO 38) /= "11") ELSE
      mulOutreg_im(38 DOWNTO 21) + ('0' & mulOutreg_im(20));

  intdelay_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_6 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_6(0) <= gcOutreg_im;
        intdelay_reg_6(1) <= intdelay_reg_6(0);
      END IF;
    END IF;
  END PROCESS intdelay_6_process;

  gcOut_im_tmp <= intdelay_reg_6(1);

  gcOut_im <= std_logic_vector(gcOut_im_tmp);

END rtl;

