-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/amc_model_w16a16/amc_cnn_16w16a_src_DUT_HDL.vhd
-- Created: 2023-08-04 11:27:30
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 3.25521e-08
-- Target subsystem base rate: 3.25521e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        3.25521e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- dataOut                       ce_out        3.25521e-08
-- validOut                      ce_out        3.25521e-08
-- tlast                         ce_out        3.25521e-08
-- treadyOut                     ce_out        3.25521e-08
-- sampleNum                     ce_out        3.25521e-08
-- validInput                    ce_out        3.25521e-08
-- validConv1                    ce_out        3.25521e-08
-- validConv2                    ce_out        3.25521e-08
-- validDense1                   ce_out        3.25521e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: amc_cnn_16w16a_src_DUT_HDL
-- Source Path: amc_model_w16a16/DUT HDL
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.amc_cnn_16w16a_src_DUT_HDL_pkg.ALL;

ENTITY amc_cnn_16w16a_src_DUT_HDL IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        dataIn                            :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
        validIn                           :   IN    std_logic;
        enable                            :   IN    std_logic;
        treadyIn                          :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        dataOut                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        validOut                          :   OUT   std_logic;
        tlast                             :   OUT   std_logic;
        treadyOut                         :   OUT   std_logic;
        sampleNum                         :   OUT   std_logic_vector(2 DOWNTO 0);  -- ufix3
        validInput                        :   OUT   std_logic;
        validConv1                        :   OUT   std_logic;
        validConv2                        :   OUT   std_logic;
        validDense1                       :   OUT   std_logic
        );
END amc_cnn_16w16a_src_DUT_HDL;


ARCHITECTURE rtl OF amc_cnn_16w16a_src_DUT_HDL IS

  -- Component Declarations
  COMPONENT amc_cnn_16w16a_src_input_switch
    PORT( validIn                         :   IN    std_logic;
          enable                          :   IN    std_logic;
          Out1                            :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Collect_Input_into_Bursts
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Conv_Layer_1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          validIn                         :   IN    std_logic;
          enable                          :   IN    std_logic;
          ready_nx_layer                  :   IN    std_logic;
          dataOut                         :   OUT   vector_of_std_logic_vector16(0 TO 63);  -- int16 [64]
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Conv_Layer_2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          vectorIn                        :   IN    vector_of_std_logic_vector16(0 TO 63);  -- int16 [64]
          validIn                         :   IN    std_logic;
          ready_nx_layer                  :   IN    std_logic;
          vectorOut                       :   OUT   vector_of_std_logic_vector16(0 TO 15);  -- int16 [16]
          validOut                        :   OUT   std_logic;
          ready_prev                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Dense_Layer_1_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          vectorIn                        :   IN    vector_of_std_logic_vector16(0 TO 15);  -- int16 [16]
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
          validOut                        :   OUT   std_logic;
          ready_prev                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Dense_Layer_2_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_nfp_convert_sfix_16_En0_to_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_nfp_wire_single
    PORT( nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  COMPONENT amc_cnn_16w16a_src_Switch
    PORT( validOut_l4                     :   IN    std_logic;
          ready                           :   IN    std_logic;
          Out1                            :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : amc_cnn_16w16a_src_input_switch
    USE ENTITY work.amc_cnn_16w16a_src_input_switch(rtl);

  FOR ALL : amc_cnn_16w16a_src_Collect_Input_into_Bursts
    USE ENTITY work.amc_cnn_16w16a_src_Collect_Input_into_Bursts(rtl);

  FOR ALL : amc_cnn_16w16a_src_Conv_Layer_1
    USE ENTITY work.amc_cnn_16w16a_src_Conv_Layer_1(rtl);

  FOR ALL : amc_cnn_16w16a_src_Conv_Layer_2
    USE ENTITY work.amc_cnn_16w16a_src_Conv_Layer_2(rtl);

  FOR ALL : amc_cnn_16w16a_src_Dense_Layer_1_block
    USE ENTITY work.amc_cnn_16w16a_src_Dense_Layer_1_block(rtl);

  FOR ALL : amc_cnn_16w16a_src_Dense_Layer_2_block
    USE ENTITY work.amc_cnn_16w16a_src_Dense_Layer_2_block(rtl);

  FOR ALL : amc_cnn_16w16a_src_nfp_convert_sfix_16_En0_to_single
    USE ENTITY work.amc_cnn_16w16a_src_nfp_convert_sfix_16_En0_to_single(rtl);

  FOR ALL : amc_cnn_16w16a_src_nfp_wire_single
    USE ENTITY work.amc_cnn_16w16a_src_nfp_wire_single(rtl);

  FOR ALL : amc_cnn_16w16a_src_Switch
    USE ENTITY work.amc_cnn_16w16a_src_Switch(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL dataIn_signed                    : signed(15 DOWNTO 0);  -- int16
  SIGNAL Delay3_out1                      : signed(15 DOWNTO 0);  -- int16
  SIGNAL validIn_1                        : std_logic;
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL input_switch_out1                : std_logic;
  SIGNAL dataIn_1                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL validIn_2                        : std_logic;
  SIGNAL Delay5_out1_1                    : std_logic;
  SIGNAL ready_prev                       : std_logic;
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL ready_prev_l2                    : std_logic;
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL din                              : vector_of_std_logic_vector16(0 TO 63);  -- ufix16 [64]
  SIGNAL validOut_l1                      : std_logic;
  SIGNAL Conv_Layer_2_out1                : vector_of_std_logic_vector16(0 TO 15);  -- ufix16 [16]
  SIGNAL validOut_l2                      : std_logic;
  SIGNAL out_rsvd                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL validOut_l3                      : std_logic;
  SIGNAL Dense_Layer_2_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL validOut_l4                      : std_logic;
  SIGNAL Data_Type_Conversion1_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Float_Typecast_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Float_Typecast_out1_unsigned     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay6_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay5_out1_2                    : std_logic;
  SIGNAL Switch_out1                      : std_logic;
  SIGNAL delayMatch6_reg                  : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL delayMatch6_reg_next             : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL Delay7_out1                      : std_logic;
  SIGNAL count                            : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant_out1                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Equal_relop1                     : std_logic;
  SIGNAL tlast_1                          : std_logic;
  SIGNAL delayMatch7_reg                  : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL delayMatch7_reg_next             : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL Delay8_out1                      : std_logic;
  SIGNAL always_ready_out1                : std_logic;
  SIGNAL delayMatch8_reg                  : std_logic_vector(0 TO 8);  -- ufix1 [9]
  SIGNAL delayMatch8_reg_next             : std_logic_vector(0 TO 8);  -- ufix1 [9]
  SIGNAL Delay11_out1                     : std_logic;
  SIGNAL delayMatch9_reg                  : vector_of_unsigned3(0 TO 6);  -- ufix3 [7]
  SIGNAL delayMatch9_reg_next             : vector_of_unsigned3(0 TO 6);  -- ufix3 [7]
  SIGNAL Delay10_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL reduced_reg_next                 : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL validIn_3                        : std_logic;
  SIGNAL delayMatch11_reg                 : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL delayMatch11_reg_next            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL validOut_l1_1                    : std_logic;
  SIGNAL delayMatch12_reg                 : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL delayMatch12_reg_next            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL validOut_l2_1                    : std_logic;
  SIGNAL delayMatch13_reg                 : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL delayMatch13_reg_next            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL validOut_l3_1                    : std_logic;

BEGIN
  -- Samples are being received:
  -- Channel first, then Row, then Column

  u_input_switch : amc_cnn_16w16a_src_input_switch
    PORT MAP( validIn => validIn_1,
              enable => Delay5_out1,
              Out1 => input_switch_out1
              );

  u_Collect_Input_into_Bursts : amc_cnn_16w16a_src_Collect_Input_into_Bursts
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              dataIn => std_logic_vector(Delay3_out1),  -- int16
              validIn => input_switch_out1,
              dataOut => dataIn_1,  -- int16
              validOut => validIn_2
              );

  u_Conv_Layer_1 : amc_cnn_16w16a_src_Conv_Layer_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              dataIn => dataIn_1,  -- int16
              validIn => validIn_2,
              enable => Delay5_out1_1,
              ready_nx_layer => Delay_out1,
              dataOut => din,  -- int16 [64]
              validOut => validOut_l1
              );

  u_Conv_Layer_2 : amc_cnn_16w16a_src_Conv_Layer_2
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              vectorIn => din,  -- int16 [64]
              validIn => validOut_l1,
              ready_nx_layer => Delay1_out1,
              vectorOut => Conv_Layer_2_out1,  -- int16 [16]
              validOut => validOut_l2,
              ready_prev => ready_prev_l2
              );

  u_Dense_Layer_1 : amc_cnn_16w16a_src_Dense_Layer_1_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              vectorIn => Conv_Layer_2_out1,  -- int16 [16]
              validIn => validOut_l2,
              dataOut => out_rsvd,  -- int16
              validOut => validOut_l3,
              ready_prev => ready_prev
              );

  u_Dense_Layer_2 : amc_cnn_16w16a_src_Dense_Layer_2_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              dataIn => out_rsvd,  -- int16
              validIn => validOut_l3,
              dataOut => Dense_Layer_2_out1,  -- int16
              validOut => validOut_l4
              );

  u_amc_model_w16a16_DUT_HDL_nfp_convert_sfix_16_En0_to_single : amc_cnn_16w16a_src_nfp_convert_sfix_16_En0_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => Dense_Layer_2_out1,  -- int16
              nfp_out => Data_Type_Conversion1_out1  -- single
              );

  u_nfp_wire_single : amc_cnn_16w16a_src_nfp_wire_single
    PORT MAP( nfp_in => Data_Type_Conversion1_out1,  -- single
              nfp_out => Float_Typecast_out1  -- uint32
              );

  u_Switch : amc_cnn_16w16a_src_Switch
    PORT MAP( validOut_l4 => validOut_l4,
              ready => Delay5_out1_2,
              Out1 => Switch_out1
              );

  dataIn_signed <= signed(dataIn);

  enb <= clk_enable;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Delay3_out1 <= dataIn_signed;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validIn_1 <= '0';
      ELSIF enb = '1' THEN
        validIn_1 <= validIn;
      END IF;
    END IF;
  END PROCESS reduced_process;


  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay5_out1 <= enable;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Delay5_out1_1 <= Delay5_out1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay1_out1 <= ready_prev;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay_out1 <= ready_prev_l2;
      END IF;
    END IF;
  END PROCESS Delay_process;


  Float_Typecast_out1_unsigned <= unsigned(Float_Typecast_out1);

  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_out1 <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        Delay6_out1 <= Float_Typecast_out1_unsigned;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  dataOut <= std_logic_vector(Delay6_out1);

  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1_2 <= '0';
      ELSIF enb = '1' THEN
        Delay5_out1_2 <= Delay5_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  delayMatch6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch6_reg(0) <= '0';
        delayMatch6_reg(1) <= '0';
        delayMatch6_reg(2) <= '0';
        delayMatch6_reg(3) <= '0';
        delayMatch6_reg(4) <= '0';
        delayMatch6_reg(5) <= '0';
        delayMatch6_reg(6) <= '0';
      ELSIF enb = '1' THEN
        delayMatch6_reg(0) <= delayMatch6_reg_next(0);
        delayMatch6_reg(1) <= delayMatch6_reg_next(1);
        delayMatch6_reg(2) <= delayMatch6_reg_next(2);
        delayMatch6_reg(3) <= delayMatch6_reg_next(3);
        delayMatch6_reg(4) <= delayMatch6_reg_next(4);
        delayMatch6_reg(5) <= delayMatch6_reg_next(5);
        delayMatch6_reg(6) <= delayMatch6_reg_next(6);
      END IF;
    END IF;
  END PROCESS delayMatch6_process;

  Delay7_out1 <= delayMatch6_reg(6);
  delayMatch6_reg_next(0) <= Switch_out1;
  delayMatch6_reg_next(1) <= delayMatch6_reg(0);
  delayMatch6_reg_next(2) <= delayMatch6_reg(1);
  delayMatch6_reg_next(3) <= delayMatch6_reg(2);
  delayMatch6_reg_next(4) <= delayMatch6_reg(3);
  delayMatch6_reg_next(5) <= delayMatch6_reg(4);
  delayMatch6_reg_next(6) <= delayMatch6_reg(5);

  validOut <= Delay7_out1;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  HDL_Counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        count <= to_unsigned(16#0#, 3);
      ELSIF enb = '1' AND Switch_out1 = '1' THEN
        count <= count + to_unsigned(16#1#, 3);
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  Constant_out1 <= to_unsigned(16#7#, 3);

  
  Equal_relop1 <= '1' WHEN count = Constant_out1 ELSE
      '0';

  tlast_1 <= Equal_relop1;

  delayMatch7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch7_reg(0) <= '0';
        delayMatch7_reg(1) <= '0';
        delayMatch7_reg(2) <= '0';
        delayMatch7_reg(3) <= '0';
        delayMatch7_reg(4) <= '0';
        delayMatch7_reg(5) <= '0';
        delayMatch7_reg(6) <= '0';
      ELSIF enb = '1' THEN
        delayMatch7_reg(0) <= delayMatch7_reg_next(0);
        delayMatch7_reg(1) <= delayMatch7_reg_next(1);
        delayMatch7_reg(2) <= delayMatch7_reg_next(2);
        delayMatch7_reg(3) <= delayMatch7_reg_next(3);
        delayMatch7_reg(4) <= delayMatch7_reg_next(4);
        delayMatch7_reg(5) <= delayMatch7_reg_next(5);
        delayMatch7_reg(6) <= delayMatch7_reg_next(6);
      END IF;
    END IF;
  END PROCESS delayMatch7_process;

  Delay8_out1 <= delayMatch7_reg(6);
  delayMatch7_reg_next(0) <= tlast_1;
  delayMatch7_reg_next(1) <= delayMatch7_reg(0);
  delayMatch7_reg_next(2) <= delayMatch7_reg(1);
  delayMatch7_reg_next(3) <= delayMatch7_reg(2);
  delayMatch7_reg_next(4) <= delayMatch7_reg(3);
  delayMatch7_reg_next(5) <= delayMatch7_reg(4);
  delayMatch7_reg_next(6) <= delayMatch7_reg(5);

  tlast <= Delay8_out1;

  always_ready_out1 <= '1';

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_reg(0) <= '0';
        delayMatch8_reg(1) <= '0';
        delayMatch8_reg(2) <= '0';
        delayMatch8_reg(3) <= '0';
        delayMatch8_reg(4) <= '0';
        delayMatch8_reg(5) <= '0';
        delayMatch8_reg(6) <= '0';
        delayMatch8_reg(7) <= '0';
        delayMatch8_reg(8) <= '0';
      ELSIF enb = '1' THEN
        delayMatch8_reg(0) <= delayMatch8_reg_next(0);
        delayMatch8_reg(1) <= delayMatch8_reg_next(1);
        delayMatch8_reg(2) <= delayMatch8_reg_next(2);
        delayMatch8_reg(3) <= delayMatch8_reg_next(3);
        delayMatch8_reg(4) <= delayMatch8_reg_next(4);
        delayMatch8_reg(5) <= delayMatch8_reg_next(5);
        delayMatch8_reg(6) <= delayMatch8_reg_next(6);
        delayMatch8_reg(7) <= delayMatch8_reg_next(7);
        delayMatch8_reg(8) <= delayMatch8_reg_next(8);
      END IF;
    END IF;
  END PROCESS delayMatch8_process;

  Delay11_out1 <= delayMatch8_reg(8);
  delayMatch8_reg_next(0) <= always_ready_out1;
  delayMatch8_reg_next(1) <= delayMatch8_reg(0);
  delayMatch8_reg_next(2) <= delayMatch8_reg(1);
  delayMatch8_reg_next(3) <= delayMatch8_reg(2);
  delayMatch8_reg_next(4) <= delayMatch8_reg(3);
  delayMatch8_reg_next(5) <= delayMatch8_reg(4);
  delayMatch8_reg_next(6) <= delayMatch8_reg(5);
  delayMatch8_reg_next(7) <= delayMatch8_reg(6);
  delayMatch8_reg_next(8) <= delayMatch8_reg(7);

  treadyOut <= Delay11_out1;

  delayMatch9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch9_reg(0) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(1) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(2) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(3) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(4) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(5) <= to_unsigned(16#0#, 3);
        delayMatch9_reg(6) <= to_unsigned(16#0#, 3);
      ELSIF enb = '1' THEN
        delayMatch9_reg(0) <= delayMatch9_reg_next(0);
        delayMatch9_reg(1) <= delayMatch9_reg_next(1);
        delayMatch9_reg(2) <= delayMatch9_reg_next(2);
        delayMatch9_reg(3) <= delayMatch9_reg_next(3);
        delayMatch9_reg(4) <= delayMatch9_reg_next(4);
        delayMatch9_reg(5) <= delayMatch9_reg_next(5);
        delayMatch9_reg(6) <= delayMatch9_reg_next(6);
      END IF;
    END IF;
  END PROCESS delayMatch9_process;

  Delay10_out1 <= delayMatch9_reg(6);
  delayMatch9_reg_next(0) <= count;
  delayMatch9_reg_next(1) <= delayMatch9_reg(0);
  delayMatch9_reg_next(2) <= delayMatch9_reg(1);
  delayMatch9_reg_next(3) <= delayMatch9_reg(2);
  delayMatch9_reg_next(4) <= delayMatch9_reg(3);
  delayMatch9_reg_next(5) <= delayMatch9_reg(4);
  delayMatch9_reg_next(6) <= delayMatch9_reg(5);

  sampleNum <= std_logic_vector(Delay10_out1);

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg(0) <= '0';
        reduced_reg(1) <= '0';
        reduced_reg(2) <= '0';
        reduced_reg(3) <= '0';
        reduced_reg(4) <= '0';
        reduced_reg(5) <= '0';
        reduced_reg(6) <= '0';
      ELSIF enb = '1' THEN
        reduced_reg(0) <= reduced_reg_next(0);
        reduced_reg(1) <= reduced_reg_next(1);
        reduced_reg(2) <= reduced_reg_next(2);
        reduced_reg(3) <= reduced_reg_next(3);
        reduced_reg(4) <= reduced_reg_next(4);
        reduced_reg(5) <= reduced_reg_next(5);
        reduced_reg(6) <= reduced_reg_next(6);
      END IF;
    END IF;
  END PROCESS reduced_3_process;

  validIn_3 <= reduced_reg(6);
  reduced_reg_next(0) <= validIn_1;
  reduced_reg_next(1) <= reduced_reg(0);
  reduced_reg_next(2) <= reduced_reg(1);
  reduced_reg_next(3) <= reduced_reg(2);
  reduced_reg_next(4) <= reduced_reg(3);
  reduced_reg_next(5) <= reduced_reg(4);
  reduced_reg_next(6) <= reduced_reg(5);

  validInput <= validIn_3;

  delayMatch11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch11_reg(0) <= '0';
        delayMatch11_reg(1) <= '0';
        delayMatch11_reg(2) <= '0';
        delayMatch11_reg(3) <= '0';
        delayMatch11_reg(4) <= '0';
        delayMatch11_reg(5) <= '0';
        delayMatch11_reg(6) <= '0';
        delayMatch11_reg(7) <= '0';
      ELSIF enb = '1' THEN
        delayMatch11_reg(0) <= delayMatch11_reg_next(0);
        delayMatch11_reg(1) <= delayMatch11_reg_next(1);
        delayMatch11_reg(2) <= delayMatch11_reg_next(2);
        delayMatch11_reg(3) <= delayMatch11_reg_next(3);
        delayMatch11_reg(4) <= delayMatch11_reg_next(4);
        delayMatch11_reg(5) <= delayMatch11_reg_next(5);
        delayMatch11_reg(6) <= delayMatch11_reg_next(6);
        delayMatch11_reg(7) <= delayMatch11_reg_next(7);
      END IF;
    END IF;
  END PROCESS delayMatch11_process;

  validOut_l1_1 <= delayMatch11_reg(7);
  delayMatch11_reg_next(0) <= validOut_l1;
  delayMatch11_reg_next(1) <= delayMatch11_reg(0);
  delayMatch11_reg_next(2) <= delayMatch11_reg(1);
  delayMatch11_reg_next(3) <= delayMatch11_reg(2);
  delayMatch11_reg_next(4) <= delayMatch11_reg(3);
  delayMatch11_reg_next(5) <= delayMatch11_reg(4);
  delayMatch11_reg_next(6) <= delayMatch11_reg(5);
  delayMatch11_reg_next(7) <= delayMatch11_reg(6);

  validConv1 <= validOut_l1_1;

  delayMatch12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch12_reg(0) <= '0';
        delayMatch12_reg(1) <= '0';
        delayMatch12_reg(2) <= '0';
        delayMatch12_reg(3) <= '0';
        delayMatch12_reg(4) <= '0';
        delayMatch12_reg(5) <= '0';
        delayMatch12_reg(6) <= '0';
        delayMatch12_reg(7) <= '0';
      ELSIF enb = '1' THEN
        delayMatch12_reg(0) <= delayMatch12_reg_next(0);
        delayMatch12_reg(1) <= delayMatch12_reg_next(1);
        delayMatch12_reg(2) <= delayMatch12_reg_next(2);
        delayMatch12_reg(3) <= delayMatch12_reg_next(3);
        delayMatch12_reg(4) <= delayMatch12_reg_next(4);
        delayMatch12_reg(5) <= delayMatch12_reg_next(5);
        delayMatch12_reg(6) <= delayMatch12_reg_next(6);
        delayMatch12_reg(7) <= delayMatch12_reg_next(7);
      END IF;
    END IF;
  END PROCESS delayMatch12_process;

  validOut_l2_1 <= delayMatch12_reg(7);
  delayMatch12_reg_next(0) <= validOut_l2;
  delayMatch12_reg_next(1) <= delayMatch12_reg(0);
  delayMatch12_reg_next(2) <= delayMatch12_reg(1);
  delayMatch12_reg_next(3) <= delayMatch12_reg(2);
  delayMatch12_reg_next(4) <= delayMatch12_reg(3);
  delayMatch12_reg_next(5) <= delayMatch12_reg(4);
  delayMatch12_reg_next(6) <= delayMatch12_reg(5);
  delayMatch12_reg_next(7) <= delayMatch12_reg(6);

  validConv2 <= validOut_l2_1;

  delayMatch13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch13_reg(0) <= '0';
        delayMatch13_reg(1) <= '0';
        delayMatch13_reg(2) <= '0';
        delayMatch13_reg(3) <= '0';
        delayMatch13_reg(4) <= '0';
        delayMatch13_reg(5) <= '0';
        delayMatch13_reg(6) <= '0';
        delayMatch13_reg(7) <= '0';
      ELSIF enb = '1' THEN
        delayMatch13_reg(0) <= delayMatch13_reg_next(0);
        delayMatch13_reg(1) <= delayMatch13_reg_next(1);
        delayMatch13_reg(2) <= delayMatch13_reg_next(2);
        delayMatch13_reg(3) <= delayMatch13_reg_next(3);
        delayMatch13_reg(4) <= delayMatch13_reg_next(4);
        delayMatch13_reg(5) <= delayMatch13_reg_next(5);
        delayMatch13_reg(6) <= delayMatch13_reg_next(6);
        delayMatch13_reg(7) <= delayMatch13_reg_next(7);
      END IF;
    END IF;
  END PROCESS delayMatch13_process;

  validOut_l3_1 <= delayMatch13_reg(7);
  delayMatch13_reg_next(0) <= validOut_l3;
  delayMatch13_reg_next(1) <= delayMatch13_reg(0);
  delayMatch13_reg_next(2) <= delayMatch13_reg(1);
  delayMatch13_reg_next(3) <= delayMatch13_reg(2);
  delayMatch13_reg_next(4) <= delayMatch13_reg(3);
  delayMatch13_reg_next(5) <= delayMatch13_reg(4);
  delayMatch13_reg_next(6) <= delayMatch13_reg(5);
  delayMatch13_reg_next(7) <= delayMatch13_reg(6);

  validDense1 <= validOut_l3_1;

  ce_out <= clk_enable;

END rtl;

