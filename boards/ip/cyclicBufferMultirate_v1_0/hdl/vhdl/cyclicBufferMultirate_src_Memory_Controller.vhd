-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/cyclicBufferMultirate/cyclicBufferMultirate_src_Memory_Controller.vhd
-- Created: 2022-12-20 15:59:01
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cyclicBufferMultirate_src_Memory_Controller
-- Source Path: cyclicBufferMultirate/cyclicBufferMultirate/Memory Controller
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY cyclicBufferMultirate_src_Memory_Controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        validIn                           :   IN    std_logic;
        wrMem                             :   IN    std_logic;
        enable                            :   IN    std_logic;
        reset_1                           :   IN    std_logic;
        tlastIn                           :   IN    std_logic;
        validOut                          :   OUT   std_logic;
        addr                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        wr                                :   OUT   std_logic;
        tlastOut                          :   OUT   std_logic;
        treadyIn                          :   OUT   std_logic;
        stateOut                          :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
        );
END cyclicBufferMultirate_src_Memory_Controller;


ARCHITECTURE rtl OF cyclicBufferMultirate_src_Memory_Controller IS

  -- Signals
  SIGNAL addr_tmp                         : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL stateOut_tmp                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL reg_written                      : std_logic;
  SIGNAL reg_tlast                        : std_logic;
  SIGNAL reg_last_addr                    : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL state                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count                            : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL downsample_count                 : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reg_written_next                 : std_logic;
  SIGNAL reg_tlast_next                   : std_logic;
  SIGNAL reg_last_addr_next               : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL state_next                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_next                       : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL downsample_count_next            : unsigned(5 DOWNTO 0);  -- ufix6

BEGIN
  Memory_Controller_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      state <= to_unsigned(16#0#, 2);
      count <= to_unsigned(16#0000#, 16);
      reg_written <= '0';
      reg_tlast <= '0';
      reg_last_addr <= to_unsigned(16#0000#, 16);
      downsample_count <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reg_written <= reg_written_next;
        reg_tlast <= reg_tlast_next;
        reg_last_addr <= reg_last_addr_next;
        state <= state_next;
        count <= count_next;
        downsample_count <= downsample_count_next;
      END IF;
    END IF;
  END PROCESS Memory_Controller_process;

  Memory_Controller_output : PROCESS (count, downsample_count, enable, reg_last_addr, reg_tlast, reg_written,
       reset_1, state, tlastIn, validIn, wrMem)
    VARIABLE reg_written_temp : std_logic;
    VARIABLE reg_tlast_temp : std_logic;
    VARIABLE state_temp : unsigned(1 DOWNTO 0);
    VARIABLE count_temp : unsigned(15 DOWNTO 0);
    VARIABLE add_temp : unsigned(6 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(16 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(16 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#00#, 7);
    add_temp_0 := to_unsigned(16#00000#, 17);
    add_temp_1 := to_unsigned(16#00000#, 17);
    reg_written_temp := reg_written;
    reg_tlast_temp := reg_tlast;
    state_temp := state;
    count_temp := count;
    reg_last_addr_next <= reg_last_addr;
    downsample_count_next <= downsample_count;
    -- CYCLIC MEMORY CONTROLLER
    -- Maximum length for stored samples
    -- Output downsample rate
    -- States
    -- default outputs
    validOut <= '0';
    wr <= '0';
    tlastOut <= '0';
    treadyIn <= '0';
    addr_tmp <= reg_last_addr;
    -- Reset the system to default
    IF reset_1 = '1' THEN 
      state_temp := to_unsigned(16#0#, 2);
      count_temp := to_unsigned(16#0000#, 16);
      reg_written_temp := '0';
      reg_tlast_temp := '0';
    END IF;
    CASE state_temp IS
      WHEN "00" =>
        -- Wait for write/read signal and enable signal
        IF (enable AND ( NOT wrMem)) = '1' THEN 
          state_temp := to_unsigned(16#1#, 2);
          reg_written_temp := '0';
          treadyIn <= '1';
        ELSIF (enable AND wrMem) = '1' THEN 
          state_temp := to_unsigned(16#2#, 2);
          count_temp := to_unsigned(16#0000#, 16);
        ELSE 
          state_temp := to_unsigned(16#0#, 2);
        END IF;
      WHEN "01" =>
        treadyIn <= '1';
        -- Write DMA transfer samples into a buffer.
        IF (validIn AND ( NOT reg_written_temp)) = '1' THEN 
          -- Set RAM port to write
          wr <= '1';
          -- Write to the current address count
          addr_tmp <= count_temp;
          IF count_temp = to_unsigned(16#7FFF#, 16) THEN 
            -- If the count reaches the set max, stop writing and go
            -- to IDLE
            reg_written_temp := '1';
            reg_last_addr_next <= count_temp;
            count_temp := to_unsigned(16#0000#, 16);
          ELSIF (tlastIn AND ( NOT reg_tlast_temp)) = '1' THEN 
            -- If tlast is triggered, remember the end address and
            -- finish writing
            reg_written_temp := '1';
            reg_last_addr_next <= count_temp;
            count_temp := to_unsigned(16#0000#, 16);
          ELSE 
            add_temp_0 := resize(count_temp, 17) + to_unsigned(16#00001#, 17);
            IF add_temp_0(16) /= '0' THEN 
              count_temp := X"FFFF";
            ELSE 
              count_temp := add_temp_0(15 DOWNTO 0);
            END IF;
          END IF;
          -- If written flag is high, go to IDLE
          IF reg_written_temp = '1' THEN 
            state_temp := to_unsigned(16#3#, 2);
          END IF;
        END IF;
      WHEN "10" =>
        -- Read from buffer cyclically and send with constant valid
        -- high.
        IF (enable AND wrMem) = '1' THEN 
          IF downsample_count < to_unsigned(16#20#, 6) THEN 
            add_temp := resize(downsample_count, 7) + to_unsigned(16#01#, 7);
            IF add_temp(6) /= '0' THEN 
              downsample_count_next <= "111111";
            ELSE 
              downsample_count_next <= add_temp(5 DOWNTO 0);
            END IF;
          ELSE 
            -- User sends request to run cyclic buffer with previously
            -- stored samples
            validOut <= '1';
            addr_tmp <= count_temp;
            IF count_temp < reg_last_addr THEN 
              add_temp_1 := resize(count_temp, 17) + to_unsigned(16#00001#, 17);
              IF add_temp_1(16) /= '0' THEN 
                count_temp := X"FFFF";
              ELSE 
                count_temp := add_temp_1(15 DOWNTO 0);
              END IF;
            ELSE 
              count_temp := to_unsigned(16#0000#, 16);
              tlastOut <= '1';
            END IF;
            downsample_count_next <= to_unsigned(16#00#, 6);
          END IF;
        ELSIF (( NOT enable) AND ( NOT wrMem)) = '1' THEN 
          tlastOut <= '1';
          state_temp := to_unsigned(16#0#, 2);
          count_temp := to_unsigned(16#0000#, 16);
        ELSE 
          tlastOut <= '1';
        END IF;
      WHEN "11" =>
        -- Once finished writing, wait for read signal
        IF (enable AND wrMem) = '1' THEN 
          state_temp := to_unsigned(16#2#, 2);
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    stateOut_tmp <= state;
    reg_written_next <= reg_written_temp;
    reg_tlast_next <= tlastIn;
    state_next <= state_temp;
    count_next <= count_temp;
  END PROCESS Memory_Controller_output;


  addr <= std_logic_vector(addr_tmp);

  stateOut <= std_logic_vector(stateOut_tmp);

END rtl;

