-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/cyclicBufferMultirate/cyclicBufferMultirate_src_cyclicBufferMultirate.vhd
-- Created: 2022-12-20 15:59:01
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- dataOut                       ce_out        1
-- validOut                      ce_out        1
-- tlastOut                      ce_out        1
-- treadyIn                      ce_out        1
-- state                         ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cyclicBufferMultirate_src_cyclicBufferMultirate
-- Source Path: cyclicBufferMultirate/cyclicBufferMultirate
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.cyclicBufferMultirate_src_cyclicBufferMultirate_pkg.ALL;

ENTITY cyclicBufferMultirate_src_cyclicBufferMultirate IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        dataIn                            :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        validIn                           :   IN    std_logic;
        tlastIn                           :   IN    std_logic;
        treadyOut                         :   IN    std_logic;
        writeMem                          :   IN    std_logic;
        enable                            :   IN    std_logic;
        reset_1                           :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        dataOut                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        validOut                          :   OUT   std_logic;
        tlastOut                          :   OUT   std_logic;
        treadyIn                          :   OUT   std_logic;
        state                             :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
        );
END cyclicBufferMultirate_src_cyclicBufferMultirate;


ARCHITECTURE rtl OF cyclicBufferMultirate_src_cyclicBufferMultirate IS

  ATTRIBUTE use_dsp : string;

  ATTRIBUTE use_dsp OF rtl : ARCHITECTURE IS "no";

  -- Component Declarations
  COMPONENT cyclicBufferMultirate_src_Memory_Controller
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          validIn                         :   IN    std_logic;
          wrMem                           :   IN    std_logic;
          enable                          :   IN    std_logic;
          reset_1                         :   IN    std_logic;
          tlastIn                         :   IN    std_logic;
          validOut                        :   OUT   std_logic;
          addr                            :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
          wr                              :   OUT   std_logic;
          tlastOut                        :   OUT   std_logic;
          treadyIn                        :   OUT   std_logic;
          stateOut                        :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
          );
  END COMPONENT;

  COMPONENT cyclicBufferMultirate_src_SinglePortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          addr                            :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          we                              :   IN    std_logic;
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : cyclicBufferMultirate_src_Memory_Controller
    USE ENTITY work.cyclicBufferMultirate_src_Memory_Controller(rtl);

  FOR ALL : cyclicBufferMultirate_src_SinglePortRAM_generic
    USE ENTITY work.cyclicBufferMultirate_src_SinglePortRAM_generic(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL in_1_pipe_reg                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL validIn_1                        : std_logic;
  SIGNAL Delay9_out1                      : std_logic;
  SIGNAL in_4_pipe_reg                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL writeMem_1                       : std_logic;
  SIGNAL Delay8_out1                      : std_logic;
  SIGNAL in_5_pipe_reg                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL enable_1                         : std_logic;
  SIGNAL Delay7_out1                      : std_logic;
  SIGNAL in_6_pipe_reg                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL reset_2                          : std_logic;
  SIGNAL Delay6_out1                      : std_logic;
  SIGNAL in_2_pipe_reg                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL tlastIn_1                        : std_logic;
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL validOut_1                       : std_logic;
  SIGNAL addr                             : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL wr                               : std_logic;
  SIGNAL tlastOut_1                       : std_logic;
  SIGNAL treadyIn_1                       : std_logic;
  SIGNAL stateOut                         : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL RAM_Delay_Match_0_out1           : std_logic;
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL dataIn_unsigned                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL in_0_pipe_reg                    : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL dataIn_1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay10_out1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Single_Port_RAM_System_out1      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Single_Port_RAM_System_out1_unsigned : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay_out1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL out_0_pipe_reg                   : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay_out1_1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL out_1_pipe_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Delay1_out1_1                    : std_logic;
  SIGNAL RAM_Delay_Match_1_out1           : std_logic;
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL out_2_pipe_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Delay2_out1_1                    : std_logic;
  SIGNAL Delay4_out1                      : std_logic;
  SIGNAL out_3_pipe_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Delay4_out1_1                    : std_logic;
  SIGNAL stateOut_unsigned                : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Delay3_out1                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL out_4_pipe_reg                   : vector_of_unsigned2(0 TO 1);  -- ufix2 [2]
  SIGNAL Delay3_out1_1                    : unsigned(1 DOWNTO 0);  -- ufix2

BEGIN
  u_Memory_Controller : cyclicBufferMultirate_src_Memory_Controller
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              validIn => Delay9_out1,
              wrMem => Delay8_out1,
              enable => Delay7_out1,
              reset_1 => Delay6_out1,
              tlastIn => Delay5_out1,
              validOut => validOut_1,
              addr => addr,  -- uint16
              wr => wr,
              tlastOut => tlastOut_1,
              treadyIn => treadyIn_1,
              stateOut => stateOut  -- ufix2
              );

  u_Single_Port_RAM_System : cyclicBufferMultirate_src_SinglePortRAM_generic
    GENERIC MAP( AddrWidth => 16,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => clk_enable,
              din => std_logic_vector(Delay10_out1),
              addr => addr,
              we => wr,
              dout => Single_Port_RAM_System_out1
              );

  enb <= clk_enable;

  in_1_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_1_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_1_pipe_reg(0) <= validIn;
        in_1_pipe_reg(1) <= in_1_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;

  validIn_1 <= in_1_pipe_reg(1);

  Delay9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1 <= validIn_1;
      END IF;
    END IF;
  END PROCESS Delay9_process;


  in_4_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_4_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_4_pipe_reg(0) <= writeMem;
        in_4_pipe_reg(1) <= in_4_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;

  writeMem_1 <= in_4_pipe_reg(1);

  Delay8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay8_out1 <= writeMem_1;
      END IF;
    END IF;
  END PROCESS Delay8_process;


  in_5_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_5_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_5_pipe_reg(0) <= enable;
        in_5_pipe_reg(1) <= in_5_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_5_pipe_process;

  enable_1 <= in_5_pipe_reg(1);

  Delay7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay7_out1 <= enable_1;
      END IF;
    END IF;
  END PROCESS Delay7_process;


  in_6_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_6_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_6_pipe_reg(0) <= reset_1;
        in_6_pipe_reg(1) <= in_6_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_6_pipe_process;

  reset_2 <= in_6_pipe_reg(1);

  Delay6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay6_out1 <= reset_2;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  in_2_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_2_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_2_pipe_reg(0) <= tlastIn;
        in_2_pipe_reg(1) <= in_2_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;

  tlastIn_1 <= in_2_pipe_reg(1);

  Delay5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay5_out1 <= tlastIn_1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  RAM_Delay_Match_0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      RAM_Delay_Match_0_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        RAM_Delay_Match_0_out1 <= validOut_1;
      END IF;
    END IF;
  END PROCESS RAM_Delay_Match_0_process;


  Constant_out1 <= to_unsigned(0, 32);

  dataIn_unsigned <= unsigned(dataIn);

  in_0_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_0_pipe_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_0_pipe_reg(0) <= dataIn_unsigned;
        in_0_pipe_reg(1) <= in_0_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;

  dataIn_1 <= in_0_pipe_reg(1);

  Delay10_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay10_out1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay10_out1 <= dataIn_1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  Single_Port_RAM_System_out1_unsigned <= unsigned(Single_Port_RAM_System_out1);

  
  Switch_out1 <= Constant_out1 WHEN RAM_Delay_Match_0_out1 = '0' ELSE
      Single_Port_RAM_System_out1_unsigned;

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1 <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  out_0_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_0_pipe_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_0_pipe_reg(0) <= Delay_out1;
        out_0_pipe_reg(1) <= out_0_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_0_pipe_process;

  Delay_out1_1 <= out_0_pipe_reg(1);

  dataOut <= std_logic_vector(Delay_out1_1);

  Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1 <= RAM_Delay_Match_0_out1;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  out_1_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_1_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_1_pipe_reg(0) <= Delay1_out1;
        out_1_pipe_reg(1) <= out_1_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_1_pipe_process;

  Delay1_out1_1 <= out_1_pipe_reg(1);

  RAM_Delay_Match_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      RAM_Delay_Match_1_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        RAM_Delay_Match_1_out1 <= tlastOut_1;
      END IF;
    END IF;
  END PROCESS RAM_Delay_Match_1_process;


  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1 <= RAM_Delay_Match_1_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  out_2_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_2_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_2_pipe_reg(0) <= Delay2_out1;
        out_2_pipe_reg(1) <= out_2_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_2_pipe_process;

  Delay2_out1_1 <= out_2_pipe_reg(1);

  Delay4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_out1 <= treadyIn_1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  out_3_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_3_pipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_3_pipe_reg(0) <= Delay4_out1;
        out_3_pipe_reg(1) <= out_3_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_3_pipe_process;

  Delay4_out1_1 <= out_3_pipe_reg(1);

  stateOut_unsigned <= unsigned(stateOut);

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1 <= to_unsigned(16#0#, 2);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_out1 <= stateOut_unsigned;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  out_4_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_4_pipe_reg <= (OTHERS => to_unsigned(16#0#, 2));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_4_pipe_reg(0) <= Delay3_out1;
        out_4_pipe_reg(1) <= out_4_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_4_pipe_process;

  Delay3_out1_1 <= out_4_pipe_reg(1);

  state <= std_logic_vector(Delay3_out1_1);

  ce_out <= clk_enable;

  validOut <= Delay1_out1_1;

  tlastOut <= Delay2_out1_1;

  treadyIn <= Delay4_out1_1;

END rtl;

